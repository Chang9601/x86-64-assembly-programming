# 데이터 영역 메모리에 전역 변수를 정의한다.
# .comm 변수명, 변수 크기(바이트), 선택적 정렬(alignment, 변수의 주소는 정렬의 배수가 된다. 그렇지 않으면 정렬은 데이터 크기의 제곱수 중 2의 거듭제곱 값을 가지면 최대 32이다.)
        .data
        .comm num,8 # long num;

# 텍스트 영역 메모리로 코드의 시작을 명시한다.
        .text
# 라벨은 문자열이 저장된 주소이다.       
in_str:
        .string "num="
format_specifier:
        .string "%ld"
out_str:
        .string "num의 제곱=%ld\n"

# main() 함수를 전역 기호로 선언하며 프로그램의 진입점을 나타낸다.
.globl main
main:                                   # main()
        pushq %rbp                      # %rbp 레지스터는 베이스 포인터로 사용되며 현재 스택 프레임의 기저(base)를 추적한다.
        movq %rsp, %rbp                 # %rsp 레지스터는 스택 포인터로 사용되며 스택의 가장 위에 있는 요소를 가리킨다.
                                        # 함수에 대한 정적 스택 공간이 충분하지 않을 수 있기에 이 경우 스택 프레임의 기저를 스택 프레임 레지스터에 저장해야 한다. 
                                        # %rbp 레지스터는 피호출자 저장 레지스터이므로 변경하기 전에 저장해야 한다. 
                                        # 스택 프레임은 함수 호출마다 지역 변수와 기타 데이터를 저장하는 스택 영역 메모리에 생성되는 새로운 공간이다.
                                        # 스택 프레임을 설정한 후에는 지역 변수를 저장하고 접근하는 데 사용할 수 있다.
                                        # 1. 레지스터에 맞지 않는 인자(e,g,. 구조체)는 call 명령어 전에 스택에 푸시되며 %rsp 레지스터를 기준으로 접근할 수 있다. 이 방식으로 인자를 참조할 때 스택 프레임의 크기를 고려해야 한다.
                                        # 2. 함수가 6개 이상의 정수 또는 포인터 인자를 가지고 있는 경우 스택에 푸시된다.
                                        # 3. 스택 인자의 경우, 낮은 번호의 인자가 스택 포인터에 더 가까이 위치한다. 즉, 해당되는 경우 인자가 오른쪽에서 왼쪽으로 푸시된다.
                                        # 4. 지역 변수는 함수 프롤로그에서 %rsp 레지스터에서 특정 값만큼 뺀 공간에 저장된다.
                                        #
        movq $in_str, %rdi              # printf("num=");
        movq $0, %rax                   # printf() 함수는 %rax 레지스터에 0이 필요하다.
        call printf                     # call 명령어가 실행되면 명령어의 주소가 반환 주소로 스택에 푸시되고 제어가 지정된 함수로 전달된다.
                                        # 계산 중에 레지스터 인자를 임시 값 저장에 사용한다면 printf() 함수와 같은 함수 호출 시에 덮어쓰일 수 있다.
                                        # 해결책.
                                        # 1. 함수 호출 전에 레지스터 인수를 푸시(push)하고 호출 후에 팝(pop)한다.
                                        # 2. 피호출자 저장 레지스터를 사용한다. 각 레지스터의 현재 값은 스택에 푸시되고 나중에 복원되어야 한다.
                                        #
        movq $format_specifier, %rdi    # scanf("%ld", &num);
        movq $num, %rsi                 # 
        movq $0, %rax                   # scanf() 함수는 %rax 레지스터에 0이 필요하다.
        call scanf                      # 다음 레지스터(%rdi, %rsi, %rdx, %rcx, %r8, %r9)는 호출된 함수에 첫 6개의 정수 또는 포인터 매개변수를 전달하는 데 사용된다. 
                                        # 추가 매개변수(또는 값으로 전달되는 구조체와 같은 큰 매개변수)는 스택을 통해 전달된다.
                                        #
        movq $out_str, %rdi             # printf("num의 제곱은 %ld", num * num);
        movq $num, %rsi                 #
        movq (%rsi), %rsi               #
        imulq %rsi, %rsi                #
        movq $0, %rax                   # %rax 레지스터는 함수의 반환 값이 있을 경우 그 값이 64비트 이하일 때 사용된다(구조체와 같이 큰 반환 타입은 스택을 통해 반환된다.).
        call printf                     #
                                        #
        leave                           # movq %rbp, %rsp -> popq %rbp. 스택 포인터에 수행한 모든 작업에 관계없이 반환할 때 스택 포인터를 항상 올바른 위치로 돌아가도록 보장한다.
        ret                             # 함수 종료 시 함수는 호출자에게 제어를 반환해야 하는데 이를 위해 스택을 호출된 상태로 복원해야 한다. 
                                        # 먼저 호출된 함수는 스택 포인터에 동일한 값만큼 더하여 할당한 스택 공간을 해제한다. 
                                        # 그런 다음, 이전에 저장한 레지스터를 팝한다. 
                                        # 마지막으로, ret 명령어를 사용하여 호출 지점으로 돌아가야 한다.